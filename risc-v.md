# <center>  RISC-V </center>

## 目录
+ [基础概念](#基础概念)
+ [RISC-V架构](#risc-v-架构)
    + [模块化的指令集](#模块化的指令集)
    + [通用寄存器组](#通用寄存器组)
    + [risc-v存储器访问指令](#risc-v存储器访问指令)
    + [跳转指令](#跳转指令)
    + [子程序调用](#子程序调用)
    + [risc-v指令运算](#risc-v指令运算)
    + [特权模式](#特权模式)
    + [csr寄存器（control-and-status-register）](#csr寄存器（control-and-status-register）%3A控制和状态寄存器)
+ [RISC-V指令集](#risc-v指令集)
    + [RISC-V整数指令集](#risc-v整数指令集)
        + [软件检查溢出](#软件检查溢出)
    + [寄存器](#寄存器)
    + [RV32M](#rv32m)
+ [疑问合集](#疑问合集)

## 基础概念

> 基础概念1： 处理器架构的位数是指通用寄存器的宽度，且处理器指令集架构的宽度和指令的编码长度无关系
>
> RISC：精简指令集（Reduced Instruction Set Computer） RISC-V: 是伯克利发明的一种特定指令集架构（属于 RISC 类型〉。

> 基础概念2：
>> + 通用寄存器的宽度，即指令集架构位数越多越好，可以带来更大的寻址范围和更强的运算能力
>> + 指令编码的长度越短越好，节省代码存储空间 
> 基础概念3：ARM Cortex分类
>> + Cortex-A: 面向性能密集型系统，如手机、电脑（操作系统）
>> + Cortex-M: 面向各种嵌入式应用的微控制器核，如智能家居、各种物联网设备、MCU（嵌入式）
>> + Cortex-R：面向实时应用的高性能核，（实时）
> 基础概念4： CPU 处理器 处理器核 Core的区别：处理器核和Core是指处理器内部最核心的部分，是真正的处理器内核；而处理器和CPU往往是一个完整的SoC，包含了处理器内核和其他的设备或者存储器。

## RISC-V 架构
&emsp;&emsp; RISC-V的特点就在于**极简、模块化、可定制扩展**
### 模块化的指令集
+ RISC-V架构的指令数目十分简洁，基本RISC-V指令数目仅有40多条，加上其他模块化扩展指令总共几十条。
+ RISC-V 每个模块用英文字母表示
    + 最基本且强制要求实现的是 **I** 字母表示的基本整数指令子集,其他还包括M/A/F/D/C

    |扩展指令集|指令数|                    描述                       | 
    |:----------:|:------:|:------------------------------------------|
    | M |   8  | 整数乘法与除法指令|
    | A |  11  |存储器原子（Atomic）操作指令和Load-Reserved/Stroe-Conditional指令|
    | F |  26  |单精度（32bit）浮点指令|
    | D |  26  |双精度（64bit）浮点指令，必须支持F扩展指令|
    | C |  46  |压缩指令，指令长度为16位|

+ 以上模块有一个特定组合，IMAFD，被称为通用组合，用字母**G**表示,如RV32G表示RV32IMAFD
+ C指令集为了提高代码密度，指令长度为16位，普通为32位
+ 为了减少面积，RISC-V还提供”嵌入式“架构，字母E表示，仅需要支持16个通用整数寄存器，普通的需要32个。


### 通用寄存器组
+ RISC-V 支持32位或64位架构，RV32 RV64分别代表通用寄存器宽度为32位、64位。
+ RISC-V 架构的整数通用寄存器组，包含32个（I架构）或16个（E架构）通用整数寄存器，寄存器0被预留为常数0
+ 使用浮点模块F或D，则需要另外一个独立的浮点寄存器组, F的寄存器32位，D的64位

### RISC-V存储器访问指令
+ 推荐使用地址对齐的存储器读写操作， 也支持地址非对齐的存储器操作
+ 仅支持小端
+ 存储器读写指令不支持地址自增自减
+ 采用松散存储器模型， 对于访问不同地址存储器读写指令的执行顺序不作要求，除非用屏障指令屏蔽。

### 跳转指令
+ 无条件跳转指令（unconditional jump）
    + jal(jump and link)：用于子程序调用，同时将子程序返回地址保存在链接寄存器（link register: x1/ra ）-> jal rd, offset
    + jalr (jump and link-register)可以从子程序返回 -> jalr rd, offset(rs1)
+ 有条件跳转指令：使用两个整数操作数，进行比较,比较结果满足则进行跳转。
    + beq，bne，blt，bltu，bge，bgeu: 例如 beq rs1, rs2, label
        + beg 令只有在操作数寄存器 rs1 中的数值与操作数寄存器 rs2 中的数值相 时，才会跳转
        + bne 指令只有在操作数寄存器 rs1 中的数值与操作数寄存器 rs2 中的数值不相等时，才会跳转。
        + bit 指令只有在操作数寄存器 rs1 中的有符号数小于操作数寄存器 rs2 中的有符号数时，才会跳转
        + bltu 指令只有在操作数寄存器 rs1 中的无符号数小于操作数寄存器 rs2 中的无符号数时，才会跳转
        + bge 指令只有在操作数寄存器 rs1 中的有符号数大于或等于操作数寄存器 rs2 中的符号数时，才会跳转
        + bgeu 指令只有在操作数寄存器 rs1 的无符号数大于或等于操作数寄存器 rs2 中的无符号数时，才会跳转
+ 跳转的静态分支预测机制，动态分支预测机制。

### 子程序调用
+ 进入子函数后，用存储器写（store）保存当前上下文到系统存储器堆栈区中，此过程称为保存现场
+ 退出子函数时，用存储器读（load）从系统存储器堆栈区读出之前保存的上下文，此过程称为恢复现场
+ RISC-V 放弃使用一次读多个（Load Multi）或一次写多个（Store Multi）寄存器指令。

### RISC-V指令运算
+ 运算指令产生错误时，不会产生软件异常，而是产生某个特殊的默认值，同时设置某些状态寄存器的状态位。（推荐软件从其他方法找到这些错误）

### 特权模式
+ Machine Mode：机器模式（必选模式）
+ Supervisor Mode：监督模式
+ User Mode： 用户模式
+ RISC-V 架构也支持不同的存储器地址管理机制（MMU），包括对于物理地址和虚拟地址的管理机制。

### CSR寄存器（Control and Status Register）:控制和状态寄存器
+ CSR寄存器访问专用CSR指令， CSRRW, CSRRS, CSRRC, CSRRWI, CSRRSI 以及 CSRRCI 指令:
    + csrrw 指令完成两项操作：csrrw rd, csr, rs1
        + 将csr 索引的 CSR 寄存器值读出，写回结果寄存器 rd
        + 将操作数寄存器 rsl 中的值写入 csr 索引的 CSR 寄存器中。
    + csrrs 令完成两项操作
        + 将csr 索引的 CSR 存器值读出，写回结果寄存器 rd
        + 以操作数寄存器 rs1 值逐位作为参考，如果 rs1 中的值某个bit位为 1，则将csr索引的CSR寄存器中对应的比特位置清为1,其他位则不受影响
    + csrrc 指令完成两项操作：
        + 将csr 索引的 CSR 寄存器的值读出，写回结果寄存器 rd 中。
        + 以操作数寄存器 rs1 中的值逐位作为参考，如果 rs1 中的值某个比特位为0 ，则将csr索引的CSR寄存器中对应的比特位清为0, 其他位不受影响。
    + csrrwi 令完成两项操作： csrrwi rd, csr, imm[4 : 0]
        + csr 索引的 CSR 寄存器的值读出，写回结果寄存器 rd
        + 将5位立即数（高位补0 扩展〉的值写入 csr 索引的 CSR 寄存器中。
    + csrrsi 令完成两项操作
        + csr 索引的 CSR 寄存器的值读出，写回结果寄存器 rd 中。
        + 将5位立即数（高位补0 扩展〉的值逐位作为参考，如果rs1中的值某个比特位为 1,csr 索引的 CSR 寄存器中对应的比特位置清为1，其他位则不受影响
    + csrrci 令完成两项操作：
        + csr 索引的 CSR 寄存器的值读出，写回结果寄存器 rd 中。
        + 将5位立即数（高位补0扩展）的值逐位作为参考，如rs1中的值某个比特位为 0, csr 索引的 CSR 寄存器中对应的比特位清为0，其他位则不受影响。

## RISC-V指令集
### RISC-V整数指令集
+ set less than {immediate} {unsigned}:表示RV32I指令中的：slt slti sltu sltiu
+ RV32I的六种指令格式：
    + 用于寄存器-寄存器操作的 R 类型指令
    + 用于短立即数和访存 load 操作的 I 型指令
    + 用于访存 store 操作的 S 型指令
    + 用于条件跳转操作的 B 类型指令
    + 用于长立即数的 U 型指令
    + 用于无条件跳转的 J 型指令
![RV32I](./RV32I.png)
+ 所有位全是0/1的RV32I是非法指令(跳转被清零的内存区域会触发异常)
+ RV32I所有操作都在寄存器之间，没有寄存器到内存之间的操作
+ 在 RISC-V 指令集中，**ecall** 指令用于向运行时环境发出请求，例如系统调用。调试器使用 **ebreak** 指令将控制转移到调试环境。
+ **fence**指令对外部可见的访存请求，如设备 I / O 和内存访问等进行串行化。外部可见指对处理器的其他核心、线程，外部设备或协处理器可见。**fence.i** 指令同步指令和数据流。在执行 fence.i 指令之前，对于同一个硬件线程，RISC-V 不保证用存储指令写到内存指令区的数据可以被取指令取到。

#### 软件检查溢出
+ 大部分（但不是所有）程序都忽略整数算术溢出，因此 RISC-V 依赖于软件溢出检查。检查无符号加法的溢出只需要在指令后添加一个额外的分支指令：addu t0，t1，t2; bltu t0，t1，overflow。
+ 对于带符号的加法，如果已知一个操作数的符号，则溢出检查只需要在加法后添加一条分支指令：addi t0，t1，+ imm; blt t0，t1，overflow。这覆盖了常见的加立即数的情况。对于一般的带符号加法，我们需要在加法指令后添加三个附加指令，当且仅当一个操作数为负数时，结果才能小于另一个操作数，否则就是溢出。
```asm
add t0, t1, t2
slti t3, t2, 0 # t3 = (t2<0)
slt t4, t0, t1 # t4 = (t1+t2<t1)
bne t3, t4, overflow # 若 (t2<0) && (t1+t2>=t1) || (t2>=0) && (t1+t2<t1)则为溢出
```

### 寄存器
+ 临时寄存器：在函数调用的过程中不保留部分寄存器存储的值
+ 保存寄存器：在函数调用的过程中保留部分寄存器存储的值
+ 叶函数：不再调用其它函数的函数
+ RV32I函数的入口和出口：
```asm
entry_label:
    addi sp, sp, -framesize # 调整sp寄存器分配栈帧
    sw ra, framesize - 4(sp) # 保存返回地址到栈顶
    ...... # 保存其他寄存器

exit_label:
    # 恢复其他寄存器
    lw ra, framesize - 4(sp) # 恢复返回地址
    addi sp, sp, framesize # 释放栈帧空间
    ret # 返回调用点
```
+ 汇编指示符：![](./汇编常见指令.png)
```asm
.text：进入代码段。
.align 2：后续代码按 2^2 字节对齐。
.globl main：声明全局符号“main”。
.section .rodata：进入只读数据段
.balign 4：数据段按 4 字节对齐。
.string “Hello, %s!\n”：创建空字符结尾的字符串。
.string “world”：创建空字符结尾的字符串。
```
+ 链接器：编辑所有对象文件的跳转并链接指令（jump and link）中的链接部分，全称链接编辑器（link editor）。每个目标文件还包含一个符号表，存储了程序中标签，由链接过程确定地址。其中包括了数据标签和代码标签。由于在单个 32 位指令中很难指定一个 32 位的地址，RV32I 的链接器通常需要为每个标签调整为两条指令。数据标签需要调整为lui和 addi，代码标签需要调整为auipc 和 jalr。
> 链接器松弛：简单来说，就是编译器为外部函数提供的跳转指令可以进行优化，使得函数与其被调用点位置发生缩短，这个过程链接器会多次重复，直到不会再发生这类改变。
+ RISC-V为代码段分配内存的方式如图：![](./riscv分配内存.png)
+ 静态链接和动态链接：静态链接在程序运行前就把库进行了链接和加载；动态链接只有在程序运行时才会进行链接和加载。

### RV32M
+ 乘法比较复杂，需要用两条指令：为了正确地得到一个有符号或无符号的 64 位积，RISC-V 中带有四个乘法指令。要得到整数 32 位乘积（64 位中的低 32 位）就用 mul 指令。要得到高 32 位，如果操作数都是有符号数，就用 mulh 指令；如果操作数都是无符号数，就用 mulhu 指令；如果一个有符号一个无符号，可以用 mulhsu 指令。

### RV32D与RV32F
+ 使用独立的32个f寄存器，使用f、x两组寄存器的原因：可以提高处理器性能
+ 同时支持RV32D和RV32F时，单精度仅使用f寄存器低32位
+ 舍入模式通过浮点控制和状态寄存器fcsr控制, 分为静态舍入和动态舍入（默认）。
+ FP 参数寄存器（fa0-fa7），FP 保存寄存器（fs0-fs11）和 FP 临时寄存器（ft0-ft11）
+ 浮点控制和状态寄存器: 保存舍入模式和异常标志 ![](./fcsr.png)
    + 舍入模式包括向最近的偶数舍入（frm 中的 rte，000）; 向零舍入（rtz，001）; 向下(−∞)舍入（rdn，010）; 向上(+∞)舍入（rup，011）; 以及向最近的最大值舍入（rmm，100）。
    + 五个累积异常标志表示自上次由软件重置字段以来在任何浮点运算指令上出现的异常条件：NV 表示非法操作; DZ 表示除以零; OF 表示上溢; UF 表示下溢; NX 表示不精确

> 有两条加载指令（flw，fld）和两条存储指令（fsw，fsd）。他们和 lw 和 sw 拥有相同的寻址模式和指令格式。

> 添加到标准算术运算中的指令有：（fadd.s，fadd.d，fsub.s，fsub.d，fmul.s，fmul.d，fdiv.s，fdiv.d），RV32F 和 RV32D,还包括平方根（fsqrt.s，fsqrt.d）指令。

> 它们也有最小值和最大值指令（fmin.s，fmin.d， fmax.s，fmax.d），这些指令在不使用分支指令进行比较的情况下，将一对源操作数中的较小值或较大值写入目的寄存器。

> 许多浮点算法（例如矩阵乘法）在执行完乘法运算后会立即执行一条加法或减法指令。因此，RISC-V 提供了指令用于先将两个操作数相乘然后将乘积加上（fmadd.s，fmadd.d）
> 或减去（fmsub.s，fmsub.d）第三个操作数，最后再将结果写入目的寄存器。它还有在加上或减去第三个操作数之前对乘积取反的版本：fnmadd.s，fnmadd.d，fnmsub.s，fnmsub.d。

> RV32F 和 RV32D 没有提供浮点分支指令，而是提供了浮点比较指令，这些根据两个浮点的比较结果将一个整数寄存器设置为 1 或 0：feq.s，feq.d，flt.s，flt.d，fle.s，fle.d。

> RV32F 还提供了将数据从 f 寄存器（fmv.x.w）移动到 x 寄存器的指令，以及反方向移动数据的指令（fmv.w.x）。

> 符号注入指令：它从第一个源操作数复制了除符号位之外的所有内容。
>> 1. 浮点符号注入（fsgnj.s，fsgnj.d）：结果的符号位是 rs2 的符号位。
>> 2. 浮点符号取反注入（fsgnjn.s，fsgnjn.d）：结果的符号位与 rs2 的符号位相反。
>> 3. 浮点符号异或注入（fsgnjx.s，fsgnjx.d）：结果符号位是 rs1 和 rs2 的符号位异或的结果。

### RV32A原子指令
+ RV32A 有两种类型的原子操作：
    + 内存原子操作（Atomic memory operation, AMO）:令对内存中的操作数执行一个原子操作，并将目标寄存器设置为操作前的内存值。原子表示内存读写之间的过程不会被打断，内存值也不会被其它处理器修改。
    + 加载保留/条件存储（load reserved / store conditional）:加载保留和条件存储保证了它们两条指令之间的操作的原子性。加载保留读取一个内存字，存入目标寄存器中，并留下这个字的保留记录。而如果条件存储的目标地址上存在保留记录，它就把字存入这个地址。如果存入成功，它向目标寄存器中写入 0；否则写入一个非0 的错误代码。
> AMO 和 LR/SC 指令要求内存地址对齐，因为保证跨 cache 行的原子读写的难度很大。
> aq 标志位会限制所有后面内存访问指令，rl 标志位会限制所有前面内存访问指令，而 aqrl 是前两者的效果叠加。分别使用 aq 和 rl 标志位，可以人为的划定一个范围，把这两者之间的内存访问指令框起来,会有内存先后顺序


## 疑问合集：
> question: PC不是通用寄存器，那么PC值从哪里加载？
>> answer: 使用PC专用寄存器, 而不是通用寄存器, 使得能够修改PC值的指令变少了，提高分支跳转的预测准确性
