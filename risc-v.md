# <center>  RISC-V </center>

## 目录
+ [基础概念](#基础概念)
+ [RISC-V架构](#risc-v-架构)
    + [模块化的指令集](#模块化的指令集)
    + [通用寄存器组](#通用寄存器组)
    + [risc-v存储器访问指令](#risc-v存储器访问指令)
    + [跳转指令](#跳转指令)
    + [子程序调用](#子程序调用)
    + [risc-v指令运算](#risc-v指令运算)
    + [特权模式](#特权模式)
    + [csr寄存器（control-and-status-register）](#csr寄存器（control-and-status-register）%3A控制和状态寄存器)
+ [RISC-V指令集](#risc-v指令集)
    + [RISC-V整数指令集](#risc-v整数指令集)
        + [软件检查溢出](#软件检查溢出)
    + [寄存器](#寄存器)
    + [RV32M](#rv32m)
+ [疑问合集](#疑问合集)

## 基础概念

> 基础概念1： 处理器架构的位数是指通用寄存器的宽度，且处理器指令集架构的宽度和指令的编码长度无关系
>
> RISC：精简指令集（Reduced Instruction Set Computer） RISC-V: 是伯克利发明的一种特定指令集架构（属于 RISC 类型〉。

> 基础概念2：
>> + 通用寄存器的宽度，即指令集架构位数越多越好，可以带来更大的寻址范围和更强的运算能力
>> + 指令编码的长度越短越好，节省代码存储空间 
> 基础概念3：ARM Cortex分类
>> + Cortex-A: 面向性能密集型系统，如手机、电脑（操作系统）
>> + Cortex-M: 面向各种嵌入式应用的微控制器核，如智能家居、各种物联网设备、MCU（嵌入式）
>> + Cortex-R：面向实时应用的高性能核，（实时）
> 基础概念4： CPU 处理器 处理器核 Core的区别：处理器核和Core是指处理器内部最核心的部分，是真正的处理器内核；而处理器和CPU往往是一个完整的SoC，包含了处理器内核和其他的设备或者存储器。

## RISC-V 架构
&emsp;&emsp; RISC-V的特点就在于**极简、模块化、可定制扩展**
### 模块化的指令集
+ RISC-V架构的指令数目十分简洁，基本RISC-V指令数目仅有40多条，加上其他模块化扩展指令总共几十条。
+ RISC-V 每个模块用英文字母表示
    + 最基本且强制要求实现的是 **I** 字母表示的基本整数指令子集,其他还包括M/A/F/D/C

    |扩展指令集|指令数|                    描述                       | 
    |:----------:|:------:|:------------------------------------------|
    | M |   8  | 整数乘法与除法指令|
    | A |  11  |存储器原子（Atomic）操作指令和Load-Reserved/Stroe-Conditional指令|
    | F |  26  |单精度（32bit）浮点指令|
    | D |  26  |双精度（64bit）浮点指令，必须支持F扩展指令|
    | C |  46  |压缩指令，指令长度为16位|

+ 以上模块有一个特定组合，IMAFD，被称为通用组合，用字母**G**表示,如RV32G表示RV32IMAFD
+ C指令集为了提高代码密度，指令长度为16位，普通为32位
+ 为了减少面积，RISC-V还提供”嵌入式“架构，字母E表示，仅需要支持16个通用整数寄存器，普通的需要32个。


### 通用寄存器组
+ RISC-V 支持32位或64位架构，RV32 RV64分别代表通用寄存器宽度为32位、64位。
+ RISC-V 架构的整数通用寄存器组，包含32个（I架构）或16个（E架构）通用整数寄存器，寄存器0被预留为常数0
+ 使用浮点模块F或D，则需要另外一个独立的浮点寄存器组, F的寄存器32位，D的64位

### RISC-V存储器访问指令
+ 推荐使用地址对齐的存储器读写操作， 也支持地址非对齐的存储器操作
+ 仅支持小端
+ 存储器读写指令不支持地址自增自减
+ 采用松散存储器模型， 对于访问不同地址存储器读写指令的执行顺序不作要求，除非用屏障指令屏蔽。

### 跳转指令
+ 无条件跳转指令（unconditional jump）
    + jal(jump and link)：用于子程序调用，同时将子程序返回地址保存在链接寄存器（link register: x1/ra ）-> jal rd, offset
    + jalr (jump and link-register)可以从子程序返回 -> jalr rd, offset(rs1)
+ 有条件跳转指令：使用两个整数操作数，进行比较,比较结果满足则进行跳转。
    + beq，bne，blt，bltu，bge，bgeu: 例如 beq rs1, rs2, label
        + beg 令只有在操作数寄存器 rs1 中的数值与操作数寄存器 rs2 中的数值相 时，才会跳转
        + bne 指令只有在操作数寄存器 rs1 中的数值与操作数寄存器 rs2 中的数值不相等时，才会跳转。
        + bit 指令只有在操作数寄存器 rs1 中的有符号数小于操作数寄存器 rs2 中的有符号数时，才会跳转
        + bltu 指令只有在操作数寄存器 rs1 中的无符号数小于操作数寄存器 rs2 中的无符号数时，才会跳转
        + bge 指令只有在操作数寄存器 rs1 中的有符号数大于或等于操作数寄存器 rs2 中的符号数时，才会跳转
        + bgeu 指令只有在操作数寄存器 rs1 的无符号数大于或等于操作数寄存器 rs2 中的无符号数时，才会跳转
+ 跳转的静态分支预测机制，动态分支预测机制。

### 子程序调用
+ 进入子函数后，用存储器写（store）保存当前上下文到系统存储器堆栈区中，此过程称为保存现场
+ 退出子函数时，用存储器读（load）从系统存储器堆栈区读出之前保存的上下文，此过程称为恢复现场
+ RISC-V 放弃使用一次读多个（Load Multi）或一次写多个（Store Multi）寄存器指令。

### RISC-V指令运算
+ 运算指令产生错误时，不会产生软件异常，而是产生某个特殊的默认值，同时设置某些状态寄存器的状态位。（推荐软件从其他方法找到这些错误）

### 特权模式
+ Machine Mode：机器模式（必选模式）
+ Supervisor Mode：监督模式
+ User Mode： 用户模式
+ RISC-V 架构也支持不同的存储器地址管理机制（MMU），包括对于物理地址和虚拟地址的管理机制。

### CSR寄存器（Control and Status Register）:控制和状态寄存器
+ CSR寄存器访问专用CSR指令， CSRRW, CSRRS, CSRRC, CSRRWI, CSRRSI 以及 CSRRCI 指令:
    + csrrw 指令完成两项操作：csrrw rd, csr, rs1
        + 将csr 索引的 CSR 寄存器值读出，写回结果寄存器 rd
        + 将操作数寄存器 rsl 中的值写入 csr 索引的 CSR 寄存器中。
    + csrrs 令完成两项操作
        + 将csr 索引的 CSR 存器值读出，写回结果寄存器 rd
        + 以操作数寄存器 rs1 值逐位作为参考，如果 rs1 中的值某个bit位为 1，则将csr索引的CSR寄存器中对应的比特位置清为1,其他位则不受影响
    + csrrc 指令完成两项操作：
        + 将csr 索引的 CSR 寄存器的值读出，写回结果寄存器 rd 中。
        + 以操作数寄存器 rs1 中的值逐位作为参考，如果 rs1 中的值某个比特位为0 ，则将csr索引的CSR寄存器中对应的比特位清为0, 其他位不受影响。
    + csrrwi 令完成两项操作： csrrwi rd, csr, imm[4 : 0]
        + csr 索引的 CSR 寄存器的值读出，写回结果寄存器 rd
        + 将5位立即数（高位补0 扩展〉的值写入 csr 索引的 CSR 寄存器中。
    + csrrsi 令完成两项操作
        + csr 索引的 CSR 寄存器的值读出，写回结果寄存器 rd 中。
        + 将5位立即数（高位补0 扩展〉的值逐位作为参考，如果rs1中的值某个比特位为 1,csr 索引的 CSR 寄存器中对应的比特位置清为1，其他位则不受影响
    + csrrci 令完成两项操作：
        + csr 索引的 CSR 寄存器的值读出，写回结果寄存器 rd 中。
        + 将5位立即数（高位补0扩展）的值逐位作为参考，如rs1中的值某个比特位为 0, csr 索引的 CSR 寄存器中对应的比特位清为0，其他位则不受影响。

## RISC-V指令集
### RISC-V整数指令集
+ set less than {immediate} {unsigned}:表示RV32I指令中的：slt slti sltu sltiu
+ RV32I的六种指令格式：
    + 用于寄存器-寄存器操作的 R 类型指令
    + 用于短立即数和访存 load 操作的 I 型指令
    + 用于访存 store 操作的 S 型指令
    + 用于条件跳转操作的 B 类型指令
    + 用于长立即数的 U 型指令
    + 用于无条件跳转的 J 型指令
![RV32I](./RV32I.png)
+ 所有位全是0/1的RV32I是非法指令(跳转被清零的内存区域会触发异常)
+ RV32I所有操作都在寄存器之间，没有寄存器到内存之间的操作
+ 在 RISC-V 指令集中，**ecall** 指令用于向运行时环境发出请求，例如系统调用。调试器使用 **ebreak** 指令将控制转移到调试环境。
+ **fence**指令对外部可见的访存请求，如设备 I / O 和内存访问等进行串行化。外部可见指对处理器的其他核心、线程，外部设备或协处理器可见。**fence.i** 指令同步指令和数据流。在执行 fence.i 指令之前，对于同一个硬件线程，RISC-V 不保证用存储指令写到内存指令区的数据可以被取指令取到。

#### 软件检查溢出
+ 大部分（但不是所有）程序都忽略整数算术溢出，因此 RISC-V 依赖于软件溢出检查。检查无符号加法的溢出只需要在指令后添加一个额外的分支指令：addu t0，t1，t2; bltu t0，t1，overflow。
+ 对于带符号的加法，如果已知一个操作数的符号，则溢出检查只需要在加法后添加一条分支指令：addi t0，t1，+ imm; blt t0，t1，overflow。这覆盖了常见的加立即数的情况。对于一般的带符号加法，我们需要在加法指令后添加三个附加指令，当且仅当一个操作数为负数时，结果才能小于另一个操作数，否则就是溢出。
```asm
add t0, t1, t2
slti t3, t2, 0 # t3 = (t2<0)
slt t4, t0, t1 # t4 = (t1+t2<t1)
bne t3, t4, overflow # 若 (t2<0) && (t1+t2>=t1) || (t2>=0) && (t1+t2<t1)则为溢出
```

### 寄存器
+ 临时寄存器：在函数调用的过程中不保留部分寄存器存储的值
+ 保存寄存器：在函数调用的过程中保留部分寄存器存储的值
+ 叶函数：不再调用其它函数的函数
+ RV32I函数的入口和出口：
```asm
entry_label:
    addi sp, sp, -framesize # 调整sp寄存器分配栈帧
    sw ra, framesize - 4(sp) # 保存返回地址到栈顶
    ...... # 保存其他寄存器

exit_label:
    # 恢复其他寄存器
    lw ra, framesize - 4(sp) # 恢复返回地址
    addi sp, sp, framesize # 释放栈帧空间
    ret # 返回调用点
```
+ 汇编指示符：![](./汇编常见指令.png)
```asm
.text：进入代码段。
.align 2：后续代码按 2^2 字节对齐。
.globl main：声明全局符号“main”。
.section .rodata：进入只读数据段
.balign 4：数据段按 4 字节对齐。
.string “Hello, %s!\n”：创建空字符结尾的字符串。
.string “world”：创建空字符结尾的字符串。
```
+ 链接器：编辑所有对象文件的跳转并链接指令（jump and link）中的链接部分，全称链接编辑器（link editor）。每个目标文件还包含一个符号表，存储了程序中标签，由链接过程确定地址。其中包括了数据标签和代码标签。由于在单个 32 位指令中很难指定一个 32 位的地址，RV32I 的链接器通常需要为每个标签调整为两条指令。数据标签需要调整为lui和 addi，代码标签需要调整为auipc 和 jalr。
> 链接器松弛：简单来说，就是编译器为外部函数提供的跳转指令可以进行优化，使得函数与其被调用点位置发生缩短，这个过程链接器会多次重复，直到不会再发生这类改变。
+ RISC-V为代码段分配内存的方式如图：![](./riscv分配内存.png)
+ 静态链接和动态链接：静态链接在程序运行前就把库进行了链接和加载；动态链接只有在程序运行时才会进行链接和加载。

### RV32M
+ 乘法比较复杂，需要用两条指令：为了正确地得到一个有符号或无符号的 64 位积，RISC-V 中带有四个乘法指令。要得到整数 32 位乘积（64 位中的低 32 位）就用 mul 指令。要得到高 32 位，如果操作数都是有符号数，就用 mulh 指令；如果操作数都是无符号数，就用 mulhu 指令；如果一个有符号一个无符号，可以用 mulhsu 指令。


## 疑问合集：
> question: PC不是通用寄存器，那么PC值从哪里加载？
>> answer: 使用PC专用寄存器, 而不是通用寄存器, 使得能够修改PC值的指令变少了，提高分支跳转的预测准确性
